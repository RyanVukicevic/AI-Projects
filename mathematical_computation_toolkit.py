# -*- coding: utf-8 -*-
"""Mathematical Computation Toolkit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Oom5awkpj7zgeellxoXsUGDjZKwxIwdw

# Import and Exceptions
"""

import math
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd


#defining error to police the input of functions
class InvalidInput(Exception):
    def __init__(self, message):
        super().__init__(message)

"""# I. Primes

## Primality Test
"""

def isPrime(primeSuspect:int) -> bool:

  #only ints and numbers 2 or above
  if primeSuspect<=1:
    raise InvalidInput("primality suspect must be an integer >=2")

  #cant be prime if even and above 2, saves time for all evens
  if primeSuspect%2==0 and primeSuspect>2:
    return False

#only need check up to and including sq root for factors
  boundary = math.sqrt(primeSuspect)

  #for nontrivial, loop thru possible factors
  for i in range(2, int(boundary)+1):
    if primeSuspect % i == 0:
      return False

  #if it gets here then the number is prime, bc checked all factor candidates and didnt return
  return True

"""##List Primes in Range"""

def listPrimesInRange(lowerBound: int, upperBound: int) -> None:

  if upperBound<=0:
    raise ValueError("upper bound must be positive")

  if upperBound<lowerBound:
    raise ValueError("upper bound must be >= lower bound")

  ogLower = lowerBound
  lowerAltered=False

#for if lower bound is negative, just make lowerbound=2 as its the same list, just saves time
  if(lowerBound<=2):
    lowerAltered=True
    lowerBound=2

  primeList = [i for i in range(lowerBound, upperBound+1) if isPrime(i)]

  if lowerAltered:
    print("list of primes in range [%d,%d]: %s" % (ogLower, upperBound, primeList))

  else:
    print("list of primes in range [%d,%d]: %s" % (lowerBound, upperBound, primeList))

"""## Prime Count in Range"""

def primeCountInRange(lowerBound:int, upperBound:int) -> int:

  if upperBound<=0:
    raise ValueError("upper bound must be positive")

  if upperBound<lowerBound:
    raise ValueError("upper bound must be >= lower bound")

#if lower bound negative, just make it 2 as the list will be the same, just saves time
  if lowerBound<0:
    lowerBound=2

  primeList = [i for i in range(lowerBound, upperBound+1) if isPrime(i)]
  return len(primeList)

"""##Prime Factorization"""

def primeFactors(numToFactorize:int) -> list:

  if numToFactorize==1 or numToFactorize==0:
    raise ValueError("0 and 1 are undefined for prime factorization")
  if numToFactorize<0:
    raise ValueError("the number must be positive for prime factorization")

#if num is prime, then return the list w only that number, omitting 1 as its trivial
  if isPrime(numToFactorize):
    lst = [numToFactorize]
    return lst

  primeFacCandidates=factors(numToFactorize)

  for prime in primeFacCandidates:
    if isPrime(prime)==False:
      primeFacCandidates.remove(prime)

    return primeFacCandidates

"""# II. Divisibility and Factorization

## Factor Finder
"""

def factors(numToFactorize:int) -> list:

  if(numToFactorize<=0):
    numToFactorize = abs(numToFactorize)

  factors = []

  for factor in range(2, numToFactorize):
    if numToFactorize % factor == 0:
      factors.append(factor)

  return factors

"""## Perfect Number Check

a number is perfect if its equal to the sum of the proper divisors, including the number itself. for example, 1, 2, 3 divide 6 and also 1+2+3=6
"""

def isPerfect(perfCandidate:int) -> bool:

  divisors = factors(perfCandidate)
  divisors.insert(0,1) #because factors() treats 1 as a trivial factor, so insert at first position

  if(sum(divisors)==perfCandidate):
    return True
  else:
    return False

"""## Greatest Common Factor"""

def gcf(num1:int, num2:int) -> int:

#if either is 0, then no gcf
  if num1==0 or num2==0:
    return 0

#either is 1, then the gcf is 1
  if num1==1 and num2!=1:
    return 1
  if num2==1 and num1!=1:
    return 1

#if either is a float
  if int(num1) != num1 or int(num2) != num2:
    return -1

#if negative just convert
  if num1<0:
    num1=abs(num1)
  if num2<0:
    num2=abs(num2)


  if num1==num2:
    return num1

  lesser = min(num1, num2)

  for i in range(lesser, -1, -1): #second param is -1 because its exclusive of end, so go to 0
    if num1%i==0 and num2%i==0:
      return i

  return -1

"""## Greatest Common Factor of 3 Numbers"""

def gcfOf3(num1:int, num2:int, num3:int) -> int:

  num1, num2, num3  = abs(num1), abs(num2), abs(num3)

  #if either is 0, then no gcf
  if any(x == 0 for x in (num1, num2, num3)):
    return 0

  #if any is 1, then the gcf is 1
  if any(x == 1 for x in (num1, num2, num3)):
    return 1

  #if any is a float
  if int(num1) != num1 or int(num2) != num2 or int(num3)!=num3:
    return -1

  minNum = min(num1, num2, num3)

  for i in range(minNum, -1, -1):
    if num1%i==0 and num2%i==0 and num3%i==0:
      return i

  return -1

"""## Least Common Multiple

"""

def lcm(num1: int, num2: int) -> int:

  lesser = min(num1, num2)

#lcm(a, 0) =-1, undefined
  if num1==0 or num2==0:
    return -1

#lcm(a, 1) = a
  if num1==1 and num2!=1:
    return num2
  if num2==1 and num1!=1:
    return num1

  if num1==num2:
    return num1

#if a%b==0, then one is just a factor of the other so the lcm is the larger, like lcm(3,9) = 9 for ex
    if num1%num2==0:
      return num1
    elif num2%num1==0:
      return num2

#two cases when one a%b!=0, either coprime or share a factor, when coprime

#coprime
  if gcf(num1, num2)==1:
    return num1*num2

#gcf>1, explicit int casting to get rid of 24.0 for ex, j want 24
  else:
    prod=num1*num2
    gcfvar = gcf(num1, num2)
    return int(prod/gcfvar)

"""##Perfect Square Check"""

from math import sqrt

def isPerfSquare(num: int) -> bool:

#if the sqrt of the number is an integer then the number is a perf square

  sqRoot = sqrt(num)

  if int(sqRoot)==sqRoot:
    return True

  else:
    return False

"""## Perfect Cube Check"""

def isPerfCube(num: int) -> bool:

  cubeRoot = round(num ** (1/3))

  return cubeRoot**3==num

"""#Factorials

##Factorial
"""

def factorial(n: int) -> int:

  if n<0:
    return factorialForNegative(n)

  prod=1
  for i in range(2, n+1):
    prod=prod*i

  return prod

"""##Factorial on Negatives

traditionally negative factorials dont exist, but its fun to imagne..
"""

def factorialForNegative(n:int) -> int: #generally accepts negatives but handles positives too

  if n==0:
    return 1

  if n>0 and n%2==0:
    return factorial(n)
  if n>0 and n%2==1:
    return -factorial(n)

#if n is even, then factorial contains even amount of factors, so -n! = n!
  posN=abs(n)
  if n%2==0:
    return factorial(posN)
#if n odd, odd amount of factors so -n! = -(n!)
  else:
    return -factorial(posN)

"""##Double Factorial

double factorial is defined as the product of all numbers of same parity, so if n even, prod of all evens [1,n], if n odd, same idea
"""

def doubleFactorial(n: int) -> int:

#double factorial for evens is positive, -n!! = n!!
#double factorial for odds is negative, -n!! = -(n)!!

  newN=abs(n)

  if n==0 or n==1:
    return 1

  if n==-1:
    return -1

  prod=1

  if newN%2==0:
    for i in  range(2, newN+1, 2):
      prod=prod*i

    return prod

  else:
    factorCounter=0
    for i in range(1, n+1, 2):
      factorCounter=factorCounter+1
      prod=prod*i

  if n<0 and factorCounter%2==1:
    return -prod
  else:
    return prod

"""##Permutation Formula

$P(n,r) = \frac{n!}{(n-r)!}$
"""

def permutation(totalObjects: int, chosenObjects: int) -> int:

    n = totalObjects
    r = chosenObjects


    if n<0 or r<0:
        raise ValueError("both the total and chosen objects must be nonnegative")

    if r>n:
        raise ValueError("total objects must be greater than or equal to chosen objects")

    if r == 0:
        return 1

    prod = 1
    for i in range(n-r+1, n+1):
        prod *= i

    return prod

"""##Combination Formula

$C(n,r) = \binom{n}{r} = \frac{n!}{r!(n - r)!}$
"""

def combination(totalObjects:int, chosenObjects:int) -> int:

#n choose r, or of n objects, how many ways can we arrange r of them

  if totalObjects < 0 or chosenObjects < 0:
        raise ValueError("Both totalObjects and r must be nonnegative")

  if chosenObjects > totalObjects:
        raise ValueError("r must not be greater than totalObjects")

  if totalObjects==chosenObjects or chosenObjects==0:
    return 1

  q1=1
  if chosenObjects>=totalObjects-chosenObjects: #then use r and n to make term simpler
    for i in range(chosenObjects+1, totalObjects+1):
      q1=q1*i
    q2= 1/factorial(totalObjects-chosenObjects)
    return int(q1*q2)

  else: #r is less than n-r, so use n-r and n to make term simpler
    for i in range(totalObjects-chosenObjects+1, totalObjects+1):
      q1=q1*i
    q2=1/factorial(r)
    return int(q1*q2)

"""##Binomial Distribution

$ P(X=x) = \binom{n}{r} p^r(1 - p)^{(n - r)} $
"""

def binomial(totalObjects: int, chosenObjects: int, probabilityOfSucess: float) -> float:

  n=totalObjects
  r=chosenObjects
  p=probabilityOfSucess

  if(p<0 or p>1):
    raise ValueError("probability, must be [0,1]")

  coeff = combination(n,r)
  prob = n**r
  failProbExp = n-r
  failProb = (1-p)**failProbExp

  return coeff*prob*failProb

"""#  Graph Theory

##Euler Walk or Circuit
"""

def eulerWalkorCircuit(degreeSeq:list):

#euler walk but not circuit exists when all have even degree besides 2

  oddDegCount=0
  for degree in degreeSeq:
    if(degree%2==1):
      oddDegCount=oddDegCount+1

  if oddDegCount==2:
    print("this graph has a euler walk, but not a euler circuit")
  elif oddDegCount==0:
    print("this graph has both a euler walk and circuit")
  else:
    print("this graph has neither euler walk or circuit")

"""## Havel-Hakimi

"""

def isGraphic(degreeSeq:list)->bool:

  # print(degreeSeq)

#condition means while there are still values in the sequence
  while degreeSeq:
    degreeSeq.sort(reverse=True)
    current = degreeSeq.pop(0)

    #put here because this can happen after an iteration or can be given from the start, so optimal here
    #also the whole list being zero only means graphic if and only if current is also zero, else the degrees will become negative
    if all(deg==0 for deg in degreeSeq) and current==0:
      return True

    # print("current:", current)
    # print(degreeSeq)
    # print("list length:", len(degreeSeq))

    #if this is true then we will end with negatives at the end as more connections here than other possible vertices, not graphic
    if current>len(degreeSeq):
      return False

    #pop highest element and decrement degrees (counting connections)
    for i in range(0, current):
      degreeSeq[i]=degreeSeq[i]-1

    # print(degreeSeq)

    #if after full iteration, degree negative then not graphic
    if any(deg<0 for deg in degreeSeq):
      return False

#if we got here then its graphic as the list became all zeros or the list no longer has any v to count deg for
  return True

"""##Is the Graph Also a Tree?"""

def isTree(degreeSeq:list):

#v is num vertices, e is num edges
#in trees, e = v-1 always, so in handshaking theorem, sum of degrees = 2e, or 2(v-1), just adapting handshaking theorem to the rules of being a tree

  if isGraphic(degreeSeq)==False:
    return False

  return sum(degreeSeq)== 2*(len(degreeSeq)-1)

"""# Functions of X

##Factoring a Quadratic Equation (Positive Inputs Right Now)
"""

def factorQuadratic(a: int, b: int, c: int):


  if a==0 or b==0 or c==0:
    print("a, b, c need to be nonzero to form a product of positive binomials")
    return None


  #if all have same gcf != 1, need to reduce it to make things easier, 2x^2+4x+2 -> x^2+2x+1 for ex
  if gcfOf3(a,b,c)!=1:
    gcfvar = gcfOf3(a,b,c) #make sure to store in var, messes up calculation otherwise
    a=int(a/gcfvar)
    b=int(b/gcfvar)
    c=int(c/gcfvar)
    # print(str(a) + str(b) + str(c))


  #discriminant, tells whether roots real or imaginary
  disc = b**2 - (4*a*c)

  if disc < 0:
    print("root(s) are imaginary, cant find")
    return None #because then roots imaginary


  elif disc == 0: #(x+i)^2
    for i in range(1, b+1):
      if i*i==a*c and i+i==b:
        string = "(x+" + str(i) + ")^2"
        return string

    else:
      for i in range(1, b+1):
        for j in range(1, b+1):
          if i*j == a*c and i+j == b:
            string = "(x+" + str(i) + ")(x+" + str(j) + ")"
            return string


#if all a,b,c negative can factor out the negative and just factor the positive variant

#(p,p,p) (p,p,n) (p,n,p) (p,n,n) (n,p,p) (n,p,n) (n,n,p) (n,n,n)
#each has 2 choices, 3 spots to fill, 2^3 posibilities

#1st is done
#2nd is

#a*c positive, b positive - i,j positive
#a*c positive, b negative - one of i,j negative

#a*c negative, b positive - the bigger of i,j positve
#a*c negative, b negative - the bigger of i,j negative

"""#Pascal's Triangle"""

def pascalsTriangle(lastRow:int) -> None:

  if lastRow<=0:
    raise ValueError("positive rows needed to generate the triangle")

  #trivial case
  prevRow = [1]
  print(prevRow)

  for row in range(2, lastRow+1):
    currentRow = [0]*(len(prevRow)+1)

    for i in range(len(currentRow)):
        if i==0 or i==len(currentRow)-1:
          currentRow[i]=1
        else: # i=curLength-1
          currentRow[i]=prevRow[i-1]+prevRow[i]
    print(currentRow)
    prevRow=currentRow

"""# Fibonacci Sequence"""

def fibonacci(lengthOfSequence:int) -> list:

  if lengthOfSequence<=0:
    raise ValueError("the length of the sequence must be positive")

  fib = [0]*lengthOfSequence

  #first two entries are 0 and 1

  for i in range(1,lengthOfSequence):
    if i==1:
      fib[i]=1
    else:
      fib[i]=fib[i-2]+fib[i-1]

  return fib

"""# Main for Testing

"""



#range as it relates to prime count
# for i in range(10, 110, 10):
#   print(str(i) + ", prime count: " + str(primeCountInRange(i)))

#primality test up to 100
# for i in range(2, 101):
#   print(str(i) + ", " + str(isPrime(i)))
# print("\n")


#lcm pairs printing
# for i in range(2, 10):
#   for j in range(2, 10):
#     if i!=j:
#       print( "(" +  str(i) + "," + str(j) + ") lcm: " + str(lcm(i, j)))

#works for all the positive variants here
# print(factorQuadratic(1, 2, 1))  # x^2 + 2x + 1 -> (x + 1)^2
# print(factorQuadratic(1, 4, 4))  # x^2 + 4x + 4 -> (x + 2)^2
# print(factorQuadratic(1, 5, 6))  # x^2 + 5x + 6 -> (x + 2)(x + 3)
# print(factorQuadratic(1, 6, 5))  # x^2 + 6x + 5 -> (x + 1)(x + 5)
# print(factorQuadratic(2, 8, 6))  # 2x^2 + 8x + 6 -> 2(x + 1)(x + 3)
# print(factorQuadratic(3, 18, 27))  # 3x^2 + 18x + 27 -> 3(x + 3)^2, x^2+6x+9

# for i in range(1, 10000):
#   if isPerfSquare(i) and isPerfCube(i):
#     print(str(i), isPerfSquare(i), isPerfCube(i))
# print("\n")

# for i in range(1, 100):
#   if isPerfSquare(i) or isPerfCube(i):
#     print(str(i), isPerfSquare(i), isPerfCube(i))

# for i in range(0, 11):
#   print(i, factorial(i), negativeFactorial(-i))

# for i in  range(1, 11):
#   print(i, doubleFactorial(i), -i, doubleFactorial(-i))

# print(combination(10, 1))
# print(combination(10, 0))
# print(combination(1, 1))
# print(combination(1, 0))
# print(combination(0, 0))
# print(combination(-1,0))
# print(combination(6,4))
# print(combination(6,5))
# print(combination(6,6))

# listPrimesInRange(-10, 100)
# listPrimesInRange(2, 100)
# listPrimesInRange(1, 1)
# listPrimesInRange(0, 1)
# listPrimesInRange(-1, 1)

# print(permutation(7, 5))
# print(permutation(5, 3))
# print(permutation(5, 0))
# print(permutation(6, 2))
# print(permutation(10, 5))

# pascalsTriangle(20)
# print("\n")

# print(fibonacci(100))
# print("\n")

# for i in range(2,21):
  # print(i, factors(i), primeFactors(i))



# graphical sequences (should return True)
print(isGraphic([3, 3, 2, 2, 2]))      # True
print(isGraphic([4, 3, 3, 2, 2, 2]))   # True
print(isGraphic([0]))                 # True
print(isGraphic([1, 1]))              # True
print(isGraphic([2, 2, 2, 2]))        # True

# non-graphical sequences (should return False)
print(isGraphic([4, 2, 2, 2, 1]))      # False
print(isGraphic([3, 3, 3, 1]))         # False
print(isGraphic([5, 5, 5, 1, 0, 0]))   # False
print(isGraphic([2, 2, 2, 2, 5]))      # False